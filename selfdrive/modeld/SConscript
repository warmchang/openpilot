import os
import glob
from openpilot.common.file_chunker import chunk_file, get_chunk_paths

Import('env', 'arch')
chunker_file = File("#common/file_chunker.py")
lenv = env.Clone()

tinygrad_root = env.Dir("#").abspath
tinygrad_files = ["#"+x for x in glob.glob(env.Dir("#tinygrad_repo").relpath + "/**", recursive=True, root_dir=tinygrad_root)
                  if 'pycache' not in x and os.path.isfile(os.path.join(tinygrad_root, x))]

def estimate_pickle_max_size(onnx_size):
  return 1.2 * onnx_size  + 10 * 1024 * 1024  # 20% + 10MB is plenty

# Get model metadata
for model_name in ['driving_vision', 'driving_policy', 'dmonitoring_model']:
  fn = File(f"models/{model_name}").abspath
  script_files = [File(Dir("#selfdrive/modeld").File("get_model_metadata.py").abspath)]
  cmd = f'python3 {Dir("#selfdrive/modeld").abspath}/get_model_metadata.py {fn}.onnx'
  lenv.Command(fn + "_metadata.pkl", [fn + ".onnx"] + tinygrad_files + script_files, cmd)

# compile warp
# THREADS=0 is need to prevent bug: https://github.com/tinygrad/tinygrad/issues/14689
tg_flags = {
    'larch64': 'DEV=QCOM FLOAT16=1 NOLOCALS=1 JIT_BATCH_SIZE=0',
    'Darwin': f'DEV=CPU THREADS=0 HOME={os.path.expanduser("~")}', # tinygrad calls brew which needs a $HOME in the env
}.get(arch, 'DEV=CPU CPU_LLVM=1 THREADS=0')
image_flag = {
     'larch64': 'IMAGE=2',
}.get(arch, 'IMAGE=0')
script_files = [File(Dir("#selfdrive/modeld").File("compile_warp.py").abspath)]
compile_warp_cmd = f'{tg_flags} python3 {Dir("#selfdrive/modeld").abspath}/compile_warp.py '
from openpilot.common.transformations.camera import _ar_ox_fisheye, _os_fisheye
warp_targets = []
for cam in [_ar_ox_fisheye, _os_fisheye]:
  w, h = cam.width, cam.height
  warp_targets += [File(f"models/warp_{w}x{h}_tinygrad.pkl").abspath, File(f"models/dm_warp_{w}x{h}_tinygrad.pkl").abspath]
def chunk_warps(target, source, env):
  for t in warp_targets:
    chunk_file(t, 1)
chunk_targets = sum([get_chunk_paths(t, estimate_pickle_max_size(0)) for t in warp_targets], [])
lenv.Command(chunk_targets, tinygrad_files + script_files + [chunker_file],
             [compile_warp_cmd, chunk_warps])

def tg_compile(flags, model_name):
  pythonpath_string = 'PYTHONPATH="${PYTHONPATH}:' + env.Dir("#tinygrad_repo").abspath + '"'
  fn = File(f"models/{model_name}").abspath
  pkl = fn + "_tinygrad.pkl"
  onnx_path = fn + ".onnx"
  chunk_targets = get_chunk_paths(pkl, estimate_pickle_max_size(os.path.getsize(onnx_path)))
  def do_chunk(target, source, env):
    chunk_file(pkl, len(chunk_targets))
  return lenv.Command(
    chunk_targets,
    [onnx_path] + tinygrad_files + [chunker_file],
    [f'{pythonpath_string} {flags} {image_flag} python3 {Dir("#tinygrad_repo").abspath}/examples/openpilot/compile3.py {fn}.onnx {pkl}',
     do_chunk]
  )

# Compile small models
for model_name in ['driving_vision', 'driving_policy', 'dmonitoring_model']:
  tg_compile(tg_flags, model_name)

# Compile BIG model if USB GPU is available
if "USBGPU" in os.environ:
  import subprocess
  # because tg doesn't support multi-process
  devs = subprocess.check_output('python3 -c "from tinygrad import Device; print(list(Device.get_available_devices()))"', shell=True, cwd=env.Dir('#').abspath)
  if b"AMD" in devs:
    print("USB GPU detected... building")
    flags = "DEV=AMD AMD_IFACE=USB AMD_LLVM=1 NOLOCALS=0 IMAGE=0"
    bp = tg_compile(flags, "big_driving_policy")
    bv = tg_compile(flags, "big_driving_vision")
    lenv.SideEffect('lock', [bp, bv])  # tg doesn't support multi-process so build serially
  else:
    print("USB GPU not detected... skipping")
